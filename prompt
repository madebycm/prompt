#!/bin/bash
# combine_sources.sh
# This script combines every committed source code (text) file in a Git repository
# into a single file named prompt.txt.
#
# It supports optional filters:
#   --include=DIR/         Only include files in DIR/ (and its subfolders)
#   --exclude=file1,file2   Exclude any file with a basename matching file1, file2, etc.
#   --include-ext=ext1,ext2  Only include files with these extensions (without the dot)
#   --exclude-ext=ext1,ext2  Exclude files with these extensions (without the dot)
#
# The output tags now show the full absolute path based on the directory from where the script is run.
# The script ensures that any existing prompt.txt file is deleted before creating a new one.

# Default values for optional parameters.
INCLUDE=""
EXCLUDE=""
INCLUDE_EXT=""
EXCLUDE_EXT=""

# Parse command line arguments.
for arg in "$@"; do
    case $arg in
        --include=*)
            INCLUDE="${arg#*=}"
            ;;
        --exclude=*)
            EXCLUDE="${arg#*=}"
            ;;
        --include-ext=*)
            INCLUDE_EXT="${arg#*=}"
            ;;
        --exclude-ext=*)
            EXCLUDE_EXT="${arg#*=}"
            ;;
    esac
done

# If INCLUDE is set, ensure it ends with a slash.
if [ -n "$INCLUDE" ]; then
    case "$INCLUDE" in
        */) ;;  # already has trailing slash.
        *) INCLUDE="${INCLUDE}/" ;;
    esac
fi

# If INCLUDE_EXT is provided, split it into an array.
IFS=',' read -r -a includeExtArray <<< "$INCLUDE_EXT"
# If EXCLUDE_EXT is provided, split it into an array.
IFS=',' read -r -a excludeExtArray <<< "$EXCLUDE_EXT"

# If EXCLUDE (basename filtering) is provided, split it into an array.
IFS=',' read -r -a excludeArray <<< "$EXCLUDE"

# Verify that we are in a Git repository.
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Error: This directory is not a Git repository."
    exit 1
fi

# Get the absolute path of the current directory.
BASE_DIR="$(pwd)"

OUTPUT_FILE="prompt.txt"

# Delete the output file if it exists.
rm -f "$OUTPUT_FILE"

# Create a new empty output file.
touch "$OUTPUT_FILE"

# Process each file tracked in the current HEAD.
git ls-tree -r HEAD --name-only | while IFS= read -r file; do
    # Skip the output file if it's tracked by Git.
    if [ "$file" = "$OUTPUT_FILE" ]; then
        continue
    fi

    # If INCLUDE is set, only process files that start with the provided directory.
    if [ -n "$INCLUDE" ]; then
        case "$file" in
            "$INCLUDE"*) ;;  # match, continue processing.
            *) continue ;;   # no match, skip.
        esac
    fi

    # If EXCLUDE is set, check if the file's basename matches any exclude entry.
    if [ ${#excludeArray[@]} -gt 0 ]; then
        basename_file=$(basename "$file")
        for exclude in "${excludeArray[@]}"; do
            if [ "$basename_file" = "$exclude" ]; then
                continue 2  # Skip to the next file.
            fi
        done
    fi

    # Extract file extension (if any).
    ext=""
    if [[ "$file" == *.* ]]; then
        ext="${file##*.}"
    fi

    # If INCLUDE_EXT is provided, only process files with a matching extension.
    if [ -n "$INCLUDE_EXT" ]; then
        match_ext=0
        for incl in "${includeExtArray[@]}"; do
            if [ "$ext" = "$incl" ]; then
                match_ext=1
                break
            fi
        done
        if [ $match_ext -eq 0 ]; then
            continue
        fi
    fi

    # If EXCLUDE_EXT is provided, skip files with a matching extension.
    if [ -n "$EXCLUDE_EXT" ]; then
        for excl in "${excludeExtArray[@]}"; do
            if [ "$ext" = "$excl" ]; then
                continue 2
            fi
        done
    fi

    # Only process regular files that exist.
    if [ -f "$file" ]; then
        # Check if the file is a text file.
        if file "$file" | grep -q 'text'; then
            ABS_PATH="${BASE_DIR}/${file}"
            echo "<${ABS_PATH}>" >> "$OUTPUT_FILE"
            cat "$file" >> "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
            echo "</${ABS_PATH}>" >> "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
        fi
    fi
done

echo "Combined source files have been written to $OUTPUT_FILE"
